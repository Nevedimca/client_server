Client_Server
	1) Прочиать про клиент-серверную архитектуру
Архитектура «Клиент-Сервер» (также используются термины «сеть Клиент-Сервер» или «модель Клиент-Сервер») предусматривает разделение процессов предоставление услуг и отправки запросов на них на разных компьютерах в сети, каждый из которых выполняют свои задачи независимо от других.

В архитектуре «Клиент-Сервер» несколько компьютеров-клиентов (удалённые системы) посылают запросы и получают услуги от централизованной служебной машины – сервера (server – англ. «официант, обслуга»), которая также может называться хост-системой (host system, от host – англ. «хозяин», обычно гостиницы

Архитектуру «клиент-сервер» принято разделять на три класса: одно-, двух- и трёхуровневую.

Одноуровневая архитектура «клиент-сервер» (1-Tier) – такая, где все прикладные программы рассредоточены по рабочим станциям, которые обращаются к общему серверу баз данных или к общему файловому серверу. Никаких прикладных программ сервер при этом не исполняет, только предоставляет данные.

К двухуровневой архитектуре (2-Tier) «клиент-сервер» следует относить такую, в которой прикладные программы сосредоточены на сервере приложений (Application Server), а в рабочих станциях находятся программы-клиенты, которые предоставляют для пользователей интерфейс для работы с приложениями на общем сервере.

В трёхуровневой архитектуре (3-Tier) сервер баз данных, файловый сервер и другие представляют собой отдельный уровень, результаты работы которого использует сервер приложений. Логика данных и бизнес-логика находятся в сервере приложений. Все обращения клиентов к базе данных происходят через промежуточное программное обеспечение (middleware), которое находится на сервере приложений. Вследствие этого, повышается гибкость работы и производительность.

Многоуровневая архитектура (N-Tier)
В отдельный класс архитектуры «клиент-сервер» можно вынести многоуровневую архитектуру, в которой несколько серверов приложений используют результаты работы друг друга, а также данные от различных серверов баз данных, файловых серверов и других видов серверов.

	2) Что ткое HTTP и HTTPS
HTTP (от англ. HyperText Transfer Protocol — протокол передачи гипертекста) — это прикладной протокол передачи данных в сети. На текущий момент используется для получения информации с веб-сайтов. Протокол HTTP основан на использовании технологии «клиент-сервер»: клиент, отправляющий запрос, является инициатором соединения; сервер, получающий запрос, выполняет его и отправляет клиенту результат.

HTTPS (от англ. HyperText Transfer Protocol Secure — безопасный протокол передачи гипертекста) — это расширение протокола HTTP, поддерживающее шифрование посредством криптографических протоколов SSL и TLS.

Чем отличаются HTTP от HTTPS
HTTPS не является отдельным протоколом передачи данных, а представляет собой расширение протокола HTTP с надстройкой шифрования;
передаваемые по протоколу HTTP данные не защищены, HTTPS обеспечивает конфиденциальность информации путем ее шифрования;
HTTP использует порт 80, HTTPS — порт 443.

	3) HTTP методы
Для того, чтобы указать серверу на то, какое действие мы хотим произвести с ресурсом, используется тип HTTP-запроса, который также называется HTTP метод. Существует несколько HTTP методов, которые описывают действия с ресурсами. Наиболее часто используемыми являются GET и POST.
	Метод GET запрашивает информацию из указанного источника и не влияет на его содержимое. Запрос доступен для кеширования данных и добавления в закладки. Длина запроса ограничена (макс. длина URL - 2048).
	Метод POST используется для отправки данных, что может оказывать влияние на содержимое ресурса. В отличие от метода GET запросы POST не могут быть кешированы, они не остаются в истории браузера и их нельзя добавить в закладки. Запросы POST не ограничиваются в объеме.
	HEAD Аналогичен методу GET, однако в ответе сервера содержится только заголовок, без тела. Обычно применяется для того, чтобы проверить, существует ли ресурс по указанному адресу, а также не изменился ли он с момента последнего обращения.
	PUT Загружает содержимое запроса на указанный в запросе URI. Если по заданному URI ресурса нет, то сервер создает его, возвращая статус 201 (Created).
	DELETE	Удаляет указанный ресурс.
	OPTIONS Используется для описания параметров коммуникации между клиентом и сервером.
	CONNECT Преобразует соединение запроса в прозрачный TCP/IP-туннель.

	4) HTTP статус коды сервера
Код ответа (состояния) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:
1**: информационные коды, указывающие, что запрос, инициированный браузером, продолжается.
2**: коды успешного запроса. Возвращаются, когда запрос браузера был успешно получен, распознан и обработан сервером.
3**: коды перенаправления возвращаются, когда запрошенный ресурс заменен новым.
4**: http-ошибки, возникающие на стороне клиента и указывающие на наличие проблемы с запросом.
5**: коды ошибок сервера, указывающие, что запрос был принят, но ошибка на сервере не позволила выполнить его.

200: «Все в порядке». Это код, который возвращается, когда веб-страница или ресурс действуют точно так, как ожидается.
301: «Запрошенный ресурс был перемещен навсегда». Этот код возвращается, когда веб-страница или ресурс заменяется другим ресурсом. Он используется для постоянного редиректа URL-адресов.
302: это http-ошибка «Запрошенный ресурс перемещен, но был найден». Этот код используется для указания того, что запрошенный ресурс был найден, но не в том месте, где это ожидалось. Он используется для временного редиректа URL-адресов.
304: «Запрошенный ресурс не был изменен с момента последнего обращения к нему». Сообщает, что ресурсы, хранящиеся в кэше браузера, не изменились. Он используется для ускорения доставки веб-страниц за счет повторного использования ранее загруженных ресурсов.
401: «Не авторизован». Возвращается сервером, когда для доступа к целевому ресурсу отсутствуют валидные учетные данные.
http-ошибка 403: «Доступ к этому ресурсу запрещен». Возвращается, когда пользователь пытается открыть ресурс, для которого у него нет прав доступа. Например, попытка просмотра неавторизованным пользователем контента, защищенного паролем, может привести к ошибке 403.
404: «Запрошенный ресурс не найден». Наиболее распространенное сообщение об ошибке. Означает, что запрошенный ресурс не существует и сервер не знает, существовал ли он когда-либо.
405: «Метод не разрешен». Генерируется, когда хостинг-сервер (исходный сервер) поддерживает полученный метод, но целевой ресурс отсутствует.
406: «Неприемлемый ответ». Запрошенный ресурс способен генерировать только контент, неприемлемый в соответствии с заголовками Accept, отправленными в запросе.
408: «Время ожидания сервером поступления остальной части запроса из браузера истекло». Генерируется, когда сервер прерывает обработку после истечения времени ожидания полного запроса от браузера. Другими словами, сервер не получил полный запрос, отправленный браузером. Одной из возможных причин может быть перегрузка сети, приводящая к потере пакетов между браузером и сервером.
410: «Запрошенный ресурс отсутствует и не будет возвращен». Подобен коду 404 «Не найден», за исключением того, что код статуса 410, указывает, что данный статус ожидается на постоянной основе.
429: это http-ошибка «Слишком много запросов». Генерируется сервером, когда пользователь отправил слишком много запросов в заданный промежуток времени (ограничение по скорости). Иногда причиной ошибки могут быть боты, пытающиеся получить доступ к сайту. В этом случае может потребоваться изменение URL-адреса входа в панель администрирования WordPress.
499: «Клиент закрыл запрос». Возвращается NGINX, когда клиент закрывает запрос, пока NGINX все еще обрабатывает его.
500: «На сервере возникла ошибка, и запрос не мог быть завершен». Общий http-код, который также называют «внутренняя ошибка сервера». На сервере что-то пошло не так и запрошенный ресурс не был доставлен. Этот код генерируется сторонними плагинами, при сбоях PHP-кода или подключения к базе данных.
501: «Не реализовано». Эта ошибка указывает на то, что сервер не поддерживает функции, необходимые для выполнения запроса. Ошибка почти всегда связана с самим сервером, и для ее решения нужно обратиться в службу поддержки хостинг-провайдера.
502: это http-ошибка «Некорректный шлюз». Означает, что один сервер получил неверный ответ от другого. Иногда запрос занимает слишком много времени, и поэтому отменяется или удаляется сервером, а соединение с базой данных прерывается.
503: это http-ошибка «В данный момент сервер не может обработать запрос». Запрос не может быть обработан прямо сейчас. Этот код возвращается перегруженным сервером, который не может обрабатывать новые запросы.
504: «Сервер, действующий как шлюз, не смог дождаться ответа от другого сервера». Возвращается, когда в обработке запроса было задействовано два сервера, и на первом сервере истекло время ожидания ответа от второго.

	5) Что такое ядро браузера 
Браузер = оболочка + ядро
Оболочка относится например, меню, панели инструментов и т. Д. Он в основном предназначен для работы с пользовательским интерфейсом, настройки параметров и так далее. Он вызывает ядро ​​для реализации различных функций. Ядро - это программа или модуль, который отображает контент на основе языка разметки.
Ядро браузера можно разделить на две части: движок рендеринга (инженер макета или движок рендеринга) и движок JS
Движок рендеринга - отвечает за получение содержимого веб-страницы (HTML, XML, изображения и т. Д.)
Движок JS анализирует язык Javascript и выполняет язык Javascript для достижения динамических эффектов веб-страницы

	6) Какие браузеры какиие ядра используют
Blink: Google
Gecko: Mozilla
WebKit: Apple
EdgeHTML: Microsoft

	7) Что такое API
API (Application Programming Interface)– это механизмы, которые позволяют двум программным компонентам взаимодействовать друг с другом, используя набор определений и протоколов.

	8. Что такое ендпоинты
Маршрут (Route - роут) — это «имя», которое отсылает работу API к определенным эндпоинтам. Если упростить, то можно сказать, что маршрут - это URL к которому можно обратиться разными HTTP методами. Маршрут может иметь несколько эндпоинтов.
Эндпоинт (Endpoint - конечная точка) — это само обращение к маршруту отдельным HTTP методом. Эндпоинт выполняют конкретную задачу, принимают параметры и возвращают данные Клиенту.

	9) URL (URI, URL, URN)
URI - Uniform Resource Identifier (унифицированный идентификатор ресурса)– имя и адрес ресурса в сети, включает в себя URL и URN
URL - Uniform Resource Locator (унифицированный определитель местонахождения ресурса)– адрес ресурса в сети, определяет местонахождение и способ обращения к нему
URN - Unifrorm Resource Name (унифицированное имя ресурса)– имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться

	10) Идемпотентные HTTP методы
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST. Также все безопасные методы являются идемпотентными.

С точки зрения RESTful-сервиса, операция (или вызов сервиса) идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно при одном и том же результате, работая как "сеттер" в языке программирования. Другими словами, создание большого количества идентичных запросов имеет такой же эффект, как и один запрос. Заметьте, что в то время, как идемпотентные операции производят один и тот же результат на сервере (побочные эффекты), ответ сам по себе может не быть тем же самым (например, состояние ресурса может измениться между запросами).

Методы PUT и DELETE по определению идемпотентны. Тем не менее есть один нюанс с методом DELETE. Проблема в том, что успешный DELETE-запрос возвращает статус 200 (OK) или 204 (No Content), но для последующих запросов будет всё время возвращать 404 (Not Found), если только сервис не сконфигурирован так, чтобы "помечать" ресурс как удалённый без его фактического удаления.

	11) Безопасные HTTP методы
Метод HTTP является безопасным, если он не меняет состояние сервера. Другими словами, безопасный метод проводит операции "только чтение" (read-only). Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS. Все безопасные методы являются также идемпотентными, как и некоторые другие, но при этом небезопасные, такие как PUT или DELETE.

	12) Иденфикация, Аутентификация, Авторизация
	Идентификация — процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе. (система запрашивает логин, пользователь его указывает, система распознает его как существующий — это идентификация.)
	Аутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных. (система просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это аутентификация.)
	Авторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.
(система предоставит пользователю права - это авторизация.)

	13) Что такое IP
IP-адрес – это уникальный адрес, идентифицирующий устройство в интернете или локальной сети.
IP-адрес – это идентификатор, позволяющий передавать информацию между устройствами в сети: он содержит информацию о местоположении устройства и обеспечивает его доступность для связи. IP-адреса позволяют различать компьютеры, маршрутизаторы и веб-сайты в интернете и являются важным компонентом работы интернета.

	14) Что такое октаты в DNS
IP-адрес состоит из четырех частей, записанных в виде десятичных чисел с точками (например, 192.168.1.1). Каждую из этих четырех частей называют октетом. Октет представляет собой восемь двоичных цифр (например, 11000000, или 192 в десятичном виде).
Таким образом, каждый октет может принимать в двоичном виде значения от 00000000 до 11111111, или от 0 до 255 в десятичном виде.
Header — Заголовок DNS пакета, состоящий из 12 октет.

	15) Что такое порт, сколько портов у Linux сервера
Обмен информацией между узлами сети происходит посредством портов открытых для использования на узлах. 
Количество портов ограничено с учётом 16-битной адресации (216=65536, начало — «0»). Все порты разделены на три диапазона — общеизвестные (или системные, 0—1023), зарегистрированные (или пользовательские, 1024—49151) и динамические (или частные, 49152—65535).

	16) Уровни OSI
Модель функционирования сети назывется сетевая модель базовой эталонной модели взаимодействия открытых систем ISO/OSI. Кратко - модель OSI.
Модель OSI состоит из 7 уровней. Каждый уровень абстрагирован от других и ничего не знает о их существовании.
На седьмом уровне информация представляется в виде данных, на первом — в виде бит. Процесс, когда информация отправляется и переходит из данных в биты, называется инкапсуляцией. Обратный процесс, когда информация, полученная в битах на первом уровне, переходит в данные на седьмом, называется декапсуляцией. На каждом из семи уровней информация представляется в виде блоков данных протокола — PDU (Protocol Data Unit).
1) Первый, физический уровень (physical layer, L1) - Устройства физического уровня оперируют битами. Они передаются по проводам (например, через оптоволокно) или без проводов (например, через Bluetooth или IRDA, Wi-Fi, GSM, 4G и так далее).
2) Второй уровень, канальный (data link layer, L2) - решает проблему адресации при передаче информации. Канальный уровень получает биты и превращает их в кадры (frame, также «фреймы»). 
3)Третий уровень, сетевой (network layer, L3)-  маршрутизация. Для этой задачи были созданы устройства третьего уровня — маршрутизаторы (их еще называют роутерами). Маршрутизаторы получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.
4) Четвертый уровень, транспортный (transport layer, L4) на этом уровне появляются понятия портов. Тут трудятся TCP и UDP. Протоколы этого уровня отвечают за прямую связь между приложениями и за надежность доставки информации
5) Пятый уровень, сеансовый (session layer, L5)  Управляет сеансом связи, обменом информации, правами. Протоколы - L2TP, PPTP. Пятый уровень оказывает услугу следующему: управляет взаимодействием между приложениями, открывает возможности синхронизации задач, завершения сеанса, обмена информации
6) Шестой уровень, представления данных (presentation layer, L6) О задачах уровня представления вновь говорит его название. Шестой уровень занимается тем, что представляет данные (которые все еще являются PDU) в понятном человеку и машине виде
7) Седьмой уровень, прикладной (application layer)Самый многочисленный и разнообразный уровень. На нем выполняются все высокоуровненвые протоколы. Такие как POP, SMTP, RDP, HTTP и т.д. Протоколы здесь не должны задумываться о маршрутизации или гарантии доставки информации - этим занимаются нижестоящие уровни Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.


	17) Хедеры http запросов
HTTP запрос состоит из трех основных частей
1. строка запроса (Request Line) - указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
2. заголовки (Message Headers) - описывают тело сообщений, передают различные параметры и др. сведения и информацию.
Пустая строка (разделитель)
3. тело сообщения (Entity Body) – необязательный параметр  - это сами данные, которые передаются в запросе

Заголовки – это специальные параметры, которые несут определенную служебную информацию о соединении по HTTP. Некоторые заголовки имеют лишь информационный характер для пользователя или для компьютера, другие передают определенные команды, исходя из которых, сервер или клиент будет выполнять какие-то действия.

В зависимости от того, где эти заголовки могут находиться, они разделяются на:

General Headers (Основные заголовки) — должны быть и в запросах и в ответах клиента и сервера.

Request Headers (Заголовки запроса) — используются только в запросах клиента.

Response Headers (Заголовки ответа) — используются только в ответах сервера.

Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

